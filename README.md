# Лабораторна 2 #
## Завдання ##
Лабораторне завдання складається з трьох частин, першою частиною є намалювати UML діаграму класів

Загальні рекомендації:
- Використовувати можливості ООП:
  - класи
  - успадкування
  - поліморфізм
  - інкапсуляцію.
- Кожний клас повинен мати назву, яка повністю описує його суть, і інформативний склад. Атрибути і методи класів слід визначити самостійно
- Успадкування потрібно використовувати тільки тоді, коли воно має сенс. У випадку використання наслідування кількість класів-нащадків має бути не меншою 2 і не більшою 4-ьох
- При записі програми потрібно використовувати домовленості щодо оформлення коду java code convention.
- Зображати всі пари set/get (ака сеттери/геттери) для атрибутів класу не потрібно з метою уникнення засмічення діаграми
- Для реалізації операцій пошуку/сортування слід реалізувати окремий клас (в назві якого має бути присутнє слово Manager)
- UML діаграму класів можна малювати у draw.io, MS Visio або будь-якому іншому зручному інструментарії. 
- Результуючу діаграму слід залити на Google Drive  у форматі  ClassDiagram_Programming_FirstName_LastName_GroupNumber.pdf: https://drive.google.com/drive/u/0/folders/****************
#### Завдання 2 ####
> Магазин квітів. Визначити ієрархію квітів, які присутні в магазині квітів. Врахувати, що в магазині продають вазонки. Реалізувати можливість створення букету на основі заданих параметрів (наприклад 5 червоних троянд, 5 ромашок, 5 конвалій)
Реалізувати можливість  сортування знайдених квітів за двома типами параметрів (на вибір, реалізовано як два окремі методи)
Реалізація сортування має передбачати можливість сортувати як за спаданням, так і за зростанням. 
---
- Lab 2-3 questions 
  - this keyword
  - super keyword
  - final keyword
  - Блоки ініціалізації
  - enum - why they are used? how they differ from final static fields? 
  - Interface vs Abstract class
  - Inheritance in Java: extends, implements keywords
  - Make class abstract
  - Agreggation on UML diagram
  - Composition on UML diagram
  - Visibility modifiers on UML diagram
  - Make method abstract in Java
  - Creare interface in Java
  - Inner classes
  - Static vs non-static inner classes
  - how to make variable to be a constant
  - Constructors vs initialization blocks 
  - What is imutability?
  - static block vs init block

# Лабораторна 3 #
> **Модульне тестування** (англ. Unit testing) — це метод тестування програмного забезпечення, який полягає в окремому тестуванні кожного модуля коду програми. Модулем називають найменшу частину програми, яка може бути протестованою. У процедурному програмуванні модулем вважають окрему функцію або процедуру. В об'єктно-орієнтованому програмуванні — інтерфейс, клас. Модульні тести, або unit-тести, розробляються в процесі розробки програмістами та, іноді, тестувальниками білої скриньки (white-box testers).

> **Керована тестами розробка (КТР), Розробка через тестування** (англ. Test-driven development (TDD)) — технологія розробки програмного забезпечення, яка використовує короткі ітерації розробки, що починаються з попереднього написання тестів, які визначають необхідні покращення або нові функції. Кожна ітерація має на меті розробити код, який пройде ці тести. Нарешті, програміст або група вдосконалюють код для погодження змін. Один із ключових моментів TDD полягає у тому, що підготовка тестів перед написанням самого коду пришвидшує процес внесення змін. Варто зауважити, що керована тестами розробка є методологією розробки програмного забезпечення, а не його тестування.

> При використанні TDD покриття буде прямувати до 100% - оскільки тест симулює реальний сценарій, і код має реалізовувати цей сценарій. Проте, отримати 100% покриття буває іноді складно (особливо коли баги з'являються в останній момент і їх потрібно виправити негайно). Окреме питання - це тестування методів setXXX() і getXXX() (де ХХХ - назва приватного поля класу, ака сеттерів і геттерів). Золоте правило - ці методи не потребують написання тестів, якщо в них відбувається лише присвоєння значення атрибуту класу або повернення його значення. Окрім того, можливе використання бібліотек, так званих EntityTest-ів - які автоматично виконають тести щодо сеттерів і геттерів, а також методів equals і hashCode()
## Завдання ##
- Написати код до завдання з лабораторної №2
- Реалізувати проект таким чином, щоб його збірку можна було компілювати з-за допомогою  maven
- При записі програми потрібно використовувати домовленості щодо оформлення коду java code convention.
- Класи потрібно грамотно розкласти по пакетах.
- Робота з консоллю або консольне меню повинні бути мінімальними (точніше - не потрібне
непотрібне).
- В коді мають бути присутні лиш ті класи, які містяться на діаграмі класів
- Атрибути класів та їх видимість мають співпадати із зазначеними на діаграмі класів. Те саме стосується методів класів
- Реалізація сортування на даний момент не потрібна, окрім оголошення методів які не виконують жодної роботи
- Методи сортування слід помістити  в окремому класі
- Реалізувати виклик методів пошуку з класу Manager  з використанням юніт тестування
- Код не має містити статичних методів/атрибутів, окрім методів сортування в класі UtilsUitls
- Код має використовувати перелічувальний тип (Enum)
- Код слід залити в окремий репозиторій, попередньо створивши pull request (тобто код слід писати в окремому branch  на його основі зробити pull request)
- **Реалізовувати main метод *НЕ* потрібно!**

Генерацію мейвен проекту можна виконати з-за допомогою команди:

> Генерація відбувається з-за допомогою команди maven (слід виконувати з консолі):
mvn archetype:generate -DgroupId=ua.lviv.iot -DartifactId=work -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.0 -DinteractiveMode=false
# Лабораторна 4
#### *ВАЖЛИВО*: здача 4 роботи може бути виконана при наявності комітів з 3-ї роботи та здачі 3 роботи. Здача 4 і 3 роботи одночасно неможлива! Робота обов'язково має бути додана як пул реквест до головного бренча!!!! ####

- Реалізувати один з методів сортування з використанням компаратора, реалізованого як статичний вкладений клас (static inner class) 
- Реалізувати наступний з методів сортування з використанням компаратора, реалізованого як вкладений клас (inner class)
- Додати ще один метод сортування (додатковий, якого не було добавлено в рамках лабораторної роботи 2-3), який реалізує сортування з використанням анонімного класу (anonymous inner class)
- Додати ще один, 4-й метод сортування з використанням лямбда-виразів (екстра-завдання на додаткових 0.1 бали ) 
- Додати в pom.xml плагіни для перевірки коду: 
  - PMD
  - SpotBugs
  - Checkstyle  
- Виконати перевірку якості коду (mvn clean package site) та виправити всі помилки, на які вкажуть плагіни з кроку 5
---
- Lab 4 questions
  - checked vs unchecked exception
  - error vs exception
  - difference between comparing elements by equals and ==
  - static vs non-static inner classes
  - final keyword in class declaration (final class)
  - try-catch-finally
  - Comparator vs Comparable
  - Overload vs Override
  - checking code with SpotBugs - what is it looking for?
  - checking code with checkstyle - what is it looking for?
  - checking code with pmd - what is it looking for?

# Лабораторна 5 #
Дана робота присвячена роботі з файлами і операції запису, і також базується на основі лабораторних 2-4

Для реалізованої ієрархії класів в 3-й лабораторній слід реалізувати запис списку об’єктів, які присутні в менеджері, в CSV-файл. Звертаю увагу, що код слід реалізувати лише після здачі 3-4 лабораторних (здаються окремо, при спробі здачі всіх робіт одночасно студент отримає доповнення до його задачі 3). 

Нехай в рамках лабораторної 3 було реалізовано клас CrocodileManager, який містить список об’єктів, похідних від класу Crocodile. Для кожного класу, похідного від  Crocodile і в самому класі Crocodile слід реалізувати два методи:

- **public String getHeaders() { ... }** - повертає стрічку з атрибутів, присутніх в даному класі, розділеному через кому
- **public String toCSV() { ... }** - повертає значення атрибутів (значення полів), даного об'єкта, розділеного комами

Реалізація методу toCSV в дочірніх класах має викликати також цей метод із батьківського класу. Поля, які оголошені в батьківському класі, мають конвертуватись в стрічку, розділену комами, в батьківському класі, наприклад:
```
class Crocodile  {
    private String origin;
    ...

    public String getHeaders() { 
         return “origin”;
    }
} 

class Aligator extends Crocodile  {
    private int maxSpeed;
    ...

    public String getHeaders() { 
         return super.getHeaders() + “,” + “maxSpeed”;
    }
}
```
- Для реалізації запису у файл слід реалізувати окремий клас Writer (наприклад - CrocodileWriter), який міститиме метод public void writeToFile(List<Crocodile> crocodiles). 
- Виклик даного методу слід реалізувати з тестів
- Код має відповідати code convention
- Код слід перевірити плагінами FindBugs, PMD і Spotbugs, та виправити помилки
- Код має бути залито в репозиторій як окремий pull request (а не в окрему папку)
---
- Lab 5 questions
  - Catching multiple exception types
  - Statics in Java
  - JAR Files
  - Anonymous Inner Classes
  - Overloading in Java
  - What is generic and whre is it used?
  - how many abstract methods should be in abstarct class?
  - throw vs throws
  - Overriding hashCode() and equals()
  - @BeforeEach
  - @BeforeAll
  - @AfterEach
  - @AfterAll
  - AssertTrue, AssertFalse, AssertEquals
  - dependency in maven
  - try-with-resources
